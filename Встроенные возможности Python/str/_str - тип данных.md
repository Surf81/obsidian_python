# Класс `str`
#str #строки #типданных 
***
## Методы `str`

- **[Методы поиска в строке](#Методы%20поиска%20в%20строке)**
	**[`find()`](#`find(sub[,%20start[,%20end%20)%20->%20int`)**
	**[`rfind()`](#`rfind()`)**
	**[`index()`](#`index(sub[,%20start[,%20end%20)%20->%20int`)**
	**[`rindex()`](#`rindex()`)**
	**[`count()`](#`count(sub[,%20start[,%20end%20)%20->%20int`)**
	
- **[Пользовательская транслитерация](#Пользовательская%20транслитерация)** 
	**`maketrans()`**
	**`translate()`**


### Методы поиска в строке
#поисквстроке

#### `find(sub[, start[, end]]) -> int`
Метод `str.find()` возвращает **индекс первого совпадения** подстроки `sub` в строке `str`, где подстрока или символ `sub` находится в пределах среза `str[start:end]`. Другими словами, находит и возвращает индекс первого совпадения подстроки в строке `str`.

-   Необязательные аргументы `start` и `end` интерпретируются как в [нотации среза](https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/izvlechenie-sreza-sequence-posledovatelnosti/ "Получение среза sequence[i:j] в Python.").
-   Индекс подстроки считается всегда от начала строки, а не от начала среза, если конечно он указан.
-   Метод возвращает `-1`, если символ или подстрока `sub` не найдены.


#### `rfind()`
Работает аналогично `find()`, но просматривает строку от конца к началу. 
> Строка при этом не инвертируется!

```python
a = 'aqbsd'

print(a.rfind('sb'))
#>>> -1
print(a.rfind('bs'))
#>>> 2
```


#### `index(sub[, start[, end]]) -> int`
Метод `str.index()` возвращает индекс **первого совпадения** начала подстроки `sub` в строке `str`, где подстрока или символ `sub` находится в пределах среза `str[start:end]`.

Работает аналогично методу строки `str.find()`, за исключением того, что бросает исключение `ValueError`, если символ или подстрока `sub` не найдены в строке `str`.

-   Необязательные аргументы `start` и `end` интерпретируются как в [нотации среза](https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/izvlechenie-sreza-sequence-posledovatelnosti/ "Получение среза sequence[i:j] в Python.").
-   Индекс подстроки считается всегда от начала строки, а не от начала среза, если конечно он указан.
-   Метод бросает исключение `ValueError`, если символ или подстрока `sub` не найдены.


#### `rindex()`
Работает аналогично `rfind()` за исключением того, что бросает исключение `ValueError`, если символ или подстрока `sub` не найдены в строке `str`


#### `count(sub[, start[, end]]) -> int`
Метод `str.count()` возвращает количество вхождений подстроки `sub` в строку `str` в диапазоне индексов `[start, end]`, если они переданы в метод.
<br><br>
### Пользовательская транслитерация
#транслитерация

#### `maketrans(alph: str, newalph: str[, exclude: str] | dict) -> dict`:
Создает правила транслитерации. 
Возвращает словарь `dict` содержащий в качестве ключей коды символов `ord()` первого параметра, в качестве значений или коды символов `ord()` второго параметра или строки произвольной длины.

В качестве параметров могут быть переданы: 
- 2 строки `str` - длины строк должны совпадать, иначе ошибка. (так же не обязательная третья строка, содержащая удаляемые символы)
- словарь `dict`, содержащий пары ключ-значение в виде односимвольных строк для ключа и произвольной длины строки для значения

#### `translate(alph: str, newalph: str[, exclude: str] | dict) -> str`:
Осуществляет транслитерацию согласно переданному параметру. Если порядок транслитерации для каких-либо символов не определен, возвращаются символы в исходном варианте
```python
trans = ''.maketrans({'а': 'A' ,'ш': 'SH', 'ч': 'CH', 'я': 'YA', 'к': None})
a = 'ашчяклмн'.translate(trans)
print(trans, a)
#>>> {1072: 'A', 1096: 'SH', 1095: 'CH', 1103: 'YA'} ASHCHYAлмн

trans2 = str.maketrans('abc', 'АБЦ', 'ad')
b = 'abcdef'.translate(trans2)
print(trans2, b)
#>>> {97: 1040, 98: 1041, 99: 1062} БЦef

a = 'abcdef'
print(a.translate('abc', 'АБЦ', 'ad'))
#>>> БЦef
```
