# Класс `str`
#str #строки #типданных 
***
## Методы `str`

- **[Методы поиска в строке](#Методы%20поиска%20в%20строке)**
	**[`find()`](#`find(sub[,%20start[,%20end%20)%20->%20int`)**
	**[`rfind()`](#`rfind()`)**
	**[`index()`](#`index(sub[,%20start[,%20end%20)%20->%20int`)**
	**[`rindex()`](#`rindex()`)**
	**[`count()`](#`count(sub[,%20start[,%20end%20)%20->%20int`)**
	**[`startswith()`](#`startswith(prefix[,%20start[,%20end%20)%20->%20bool`)**
	**[`endswith()`](#`endswith()`)**
	
- **[Методы разделения и соединения строк](#Методы%20разделения%20и%20соединения%20строк)**
	**[`split()`](#`split(sep=None,%20maxsplit=-1)%20->%20list`)**
	**[`join()`](#join(iterable)%20->%20str)**
	**[`replace()`](#`replace(old,%20new[,%20count])%20->%20str`)**
	**[`splitlines()`](#`splitlines([keepends:%20bool])%20->%20list`)**
	
- **[Медоды форматирования символьных строк](#Медоды%20форматирования%20символьных%20строк)**
	**[`format()`](#`format(*args,%20**kwargs)`)**
	
- **[Пользовательская транслитерация](#Пользовательская%20транслитерация)** 
	**`maketrans()`**
	**`translate()`**


### Методы поиска в строке
#поисквстроке

#### `find(sub[, start[, end]]) -> int`
Метод `str.find()` возвращает **индекс первого совпадения** подстроки `sub` в строке `str`, где подстрока или символ `sub` находится в пределах среза `str[start:end]`. Другими словами, находит и возвращает индекс первого совпадения подстроки в строке `str`.

-   Необязательные аргументы `start` и `end` интерпретируются как в [нотации среза](https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/izvlechenie-sreza-sequence-posledovatelnosti/ "Получение среза sequence[i:j] в Python.").
-   Индекс подстроки считается всегда от начала строки, а не от начала среза, если конечно он указан.
-   Метод возвращает `-1`, если символ или подстрока `sub` не найдены.


#### `rfind()`
Работает аналогично `find()`, но просматривает строку от конца к началу. 
> Строка при этом не инвертируется!

```python
a = 'aqbsd'

print(a.rfind('sb'))
#>>> -1
print(a.rfind('bs'))
#>>> 2
```


#### `index(sub[, start[, end]]) -> int`
Метод `str.index()` возвращает индекс **первого совпадения** начала подстроки `sub` в строке `str`, где подстрока или символ `sub` находится в пределах среза `str[start:end]`.

Работает аналогично методу строки `str.find()`, за исключением того, что бросает исключение `ValueError`, если символ или подстрока `sub` не найдены в строке `str`.

-   Необязательные аргументы `start` и `end` интерпретируются как в [нотации среза](https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/izvlechenie-sreza-sequence-posledovatelnosti/ "Получение среза sequence[i:j] в Python.").
-   Индекс подстроки считается всегда от начала строки, а не от начала среза, если конечно он указан.
-   Метод бросает исключение `ValueError`, если символ или подстрока `sub` не найдены.


#### `rindex()`
Работает аналогично `rfind()` за исключением того, что бросает исключение `ValueError`, если символ или подстрока `sub` не найдены в строке `str`


#### `count(sub[, start[, end]]) -> int`
Метод `str.count()` возвращает количество вхождений подстроки `sub` в строку `str` в диапазоне индексов `[start, end]`, если они переданы в метод.


#### `startswith(prefix[, start[, end]]) -> bool`
Метод `str.startswith()` возвращает `True`, если строка `str` **начинается указанным префиксом `prefix`**, в противном случае возвращает `False`.

Ограничивать поиск начала строки можно необязательными индексами `start` и `end`. В этом случае префикс будет искаться от начала среза.

>  Префикс `prefix` также может быть `кортежем` префиксов для поиска.


#### `endswith()`
Работает аналочично `startswith()`, но поиск осуществляется в конце
<br><br>
### Методы разделения и соединения строк

#### `split(sep=None, maxsplit=-1) -> list`
Метод `str.split()` возвращает список слов (подстрок) в строке, используя `sep` в качестве разделителя строки `str`. Если задан `maxsplit`, то выполняется не более `maxsplit` разбиений, таким образом, список будет иметь не более maxsplit+1 элементов. Если `maxsplit` не указан или равен `-1`, то делаются все возможные разделения строки `str`.

Если указан разделитель `sep`, то последовательные разделители в обрабатываемой строке не группируются вместе, а считаются разделителями пустых подстрок. Аргумент `sep` может состоять из нескольких символов. Разбиение _пустой_ строки `str` с указанным разделителем возвращает значение `["]`.
```python
print('1<>2<><>3'.split('<>'))
#>>> ['1', '2', '', '3'])
```
Если `sep` не указан или задан `None`, применяется другой алгоритм разбиения:

Последовательности пробелов рассматриваются как один разделитель и если строка имеет начальные или конечные пробелы, то результат не будет содержать пустых строк в начале или конце. Следовательно, разбиение _пустой_ строки или строки, состоящей только из пробела с разделителем `None`, возвращает пустой список `[]`
```python
print('1    2    3'.split(maxsplit=1))
#>> ['1', '2    3']
```


#### `join(iterable) -> str`
Метод `str.join()` возвращает строку, которая является конкатенацией (объединением) всех строк-элементов итерируемого объекта `iterable`.

В итоговой строке элементы объединяются между собой при помощи строки-разделителя `str`.

Если в последовательности `iterable` есть какие-либо НЕ строковые значения, включая байтовые строки `bytes`, то поднимается [исключение `TypeError`](https://docs-python.ru/tutorial/vstroennye-iskljuchenija-interpretator-python/vstroennye-iskljuchenija/ "Исключения наследуемые от Exception в Python.").
> `join()` работает быстрее чем конкатенация строк


#### `replace(old, new[, count]) -> str`
Метод `str.replace()` вернет копию строки, в которой все вхождения подстроки `old` заменены на подстроку `new`.

Если указан необязательный аргумент `count`, заменяются только первые вхождения `count`.


#### `splitlines([keepends: bool]) -> list`
Метод `str.splitlines()` возвращает список строк, текста `str`, разделенного по универсальным разрывам строк. Разрывы (разделители) строк не включаются в результирующий список, если не задано значение `keepends=True`.

Универсальные разрывы (разделители) строк представляют собой надмножество [escape-последовательностей](https://docs-python.ru/tutorial/strokovye-bajtovye-literaly/escape-posledovatelnosti-python/ "escape-последовательности в Python").

В методе строки `str.splitlines()` определены следующие разделители (разрывы) строк:

-   `\n` - Перевод строки
-   `\r` - Возврат каретки
-   `\r\n` - Возврат каретки + перевод строки
-   `\v` или `\x0b` - Табуляция строк
-   `\f` или `\x0c` - Подача страницы
-   `\x1c` - Разделитель файлов
-   `\x1d` - Разделитель групп
-   `\x1e` - Разделитель записей
-   `\x85` - Следующая строка (контрольный код C1)
-   `\u2028` - Разделитель строк
-   `\u2029n` - Разделитель абзацев
<br><br>
### Медоды форматирования символьных строк

#### `format(*args, **kwargs)`
**[Описание вынесено в отдельный блок](str%20-%20форматирование.md)**


#### `capitalize()`
Делает прописной первую букву  оставляя все остальные строчными


#### `expandtabs(tab = 8)`
Заменяет символы табуляции пробелами


#### `strip([chars: str])`
Удаляет начальные и конечные пробелы в строке, либо символы `chars` . 
```python
print('feeaaedffasasddff'.strip('aedf'))
# sas
```


#### `lstrip([chars: str])`
...слева
#### `rstrip([chars: str])`
...справа


#### `cwapcase()`
Преобразует строчные буквы в прописные и наоборот


#### `upper()`
Преобразует все строчные буквы в прописные


#### `lower()`
Преобразует все прописные буквы в строчные


#### `casefold()`
Аналог метода `str.lower()`. Более корректно приводит строку к единому регистру для возможности сравнения с учетом особенностей разных (`locale`) языков


#### `ljust(ширина [, заполнение])`
Форматирование текста по левому краю путем дополнения строки до нужной ширины пробелами или символами заполнения


#### `rjust(ширина [, заполнение])`
...то же по правому краю

<br><br>
### Пользовательская транслитерация
#транслитерация

#### `maketrans(alph: str, newalph: str[, exclude: str] | dict) -> dict`:
Создает правила транслитерации. 
Возвращает словарь `dict` содержащий в качестве ключей коды символов `ord()` первого параметра, в качестве значений или коды символов `ord()` второго параметра или строки произвольной длины.

В качестве параметров могут быть переданы: 
- 2 строки `str` - длины строк должны совпадать, иначе ошибка. (так же не обязательная третья строка, содержащая удаляемые символы)
- словарь `dict`, содержащий пары ключ-значение в виде односимвольных строк для ключа и произвольной длины строки для значения


#### `translate(alph: str, newalph: str[, exclude: str] | dict) -> str`:
Осуществляет транслитерацию согласно переданному параметру. Если порядок транслитерации для каких-либо символов не определен, возвращаются символы в исходном варианте
```python
trans = ''.maketrans({'а': 'A' ,'ш': 'SH', 'ч': 'CH', 'я': 'YA', 'к': None})
a = 'ашчяклмн'.translate(trans)
print(trans, a)
#>>> {1072: 'A', 1096: 'SH', 1095: 'CH', 1103: 'YA'} ASHCHYAлмн

trans2 = str.maketrans('abc', 'АБЦ', 'ad')
b = 'abcdef'.translate(trans2)
print(trans2, b)
#>>> {97: 1040, 98: 1041, 99: 1062} БЦef

a = 'abcdef'
print(a.translate('abc', 'АБЦ', 'ad'))
#>>> БЦef
```
