# Модуль `re`
#re #регулярныевыражения [Калькулятор регулярных выражений](https://regex101.com/)
***

>### [Специальные символы](#Специальные%20символы)
>### [Флаги](#Флаги)
>### [Класс Match](#Класс%20Match)
>### [Методы модуля `re`](#Методы%20модуля%20re)
 

## Специальные символы
***

### Шаблоны, соответствующие одному символу
  
Во всех примерах ниже соответствия регулярному выражению выделяются цветом с подчёркиванием.

|Шаблон|Описание|Пример|Применяем к тексту|
|---|---|---|---|
|`.`|Один любой символ, кроме новой строки `\n`.|`м.л.ко`|<mark><u>молоко</u></mark>, <mark><u>малако</u></mark>,  И<mark><u>м0л0ко</u></mark>Ихлеб|
|`\d`|Любая цифра<br>аналогичная запись `[0-9]`|`СУ\d\d`|<mark><u>СУ35</u></mark>, <mark><u>СУ11</u></mark>1, АЛ<mark><u>СУ14</u></mark>|
|`\D`|Любой символ, кроме цифры<br>аналогичная запись `[^0-9]`|`926\D123`|<mark><u>926)123</u></mark>, 1<mark><u>926-123</u></mark>4|
|`\s`|Любой пробельный символ (пробел, табуляция, конец строки и т.п.)<br>примерная аналогия:<br>`[ \f\n\r\t\v]`|`бор\sода`|<mark><u>бор ода</u></mark>, <mark><u>бор<br>ода</u></mark>, борода|
|`\S`|Любой непробельный символ|`\S123`|<mark><u>X123</u></mark>, <mark><u>я123</u></mark>, <mark><u>!123</u></mark>456, 1 + 123456|
|`\w`|Любая буква (то, что может быть частью слова), а также цифры и `_`|`\w\w\w`|<mark><u>Год</u></mark>, <mark><u>f_3</u></mark>, <mark><u>qwe</u></mark>rt|
|`\W`|Любая не-буква, не-цифра и не подчёркивание|`сом\W`|<mark><u>сом!</u></mark>, сом|
|`[..]`|Один из символов в скобках, а также любой символ из диапазона `a-b`<br> в диапазон `[а-яА-Я]` не включаются `ё` и `Ё`|`[0-9][0-9A-Fa-f]`|<mark><u>12</u></mark>, <mark><u>1F</u></mark>, <mark><u>4b</u></mark> A<mark><u>12</u></mark>A|
|`[^..]`|Любой символ, кроме перечисленных<br>диапазоны `[^а-я]` `[^А-Я]` не учитывают `ё` и `Ё`|`<[^>]>`|<mark><u>&lt;1&gt;</u></mark>, <mark><u>&lt;a&gt;</u></mark>, &lt;&gt;&gt;|
|`[abc-], [-1]`|если нужен минус, его нужно указать последним или первым|||
|`\n`|Перенос строки|||
|`\t`|Табуляция|||
|`\r`|Возврат каретки|||
|`\`|Экранирование спец символа|`https:\\stepik.org`<br><br>`https:\\\\stepik\.org`|https:\\\\stepik.org#re<br><br><mark><u>https:\\\\stepik.org</u></mark>#re|
|`[*[(+\\\]\t]`|внутри скобок нужно экранировать только `]` и `\`|||


### Квантификаторы (указание количества повторений)

|Шаблон|Описание|Пример|Применяем к тексту|
|---|---|---|---|
|`{n}`|Ровно n повторений|`\d{4}`|1, 12, 123, <mark><u>1234</u></mark>, <mark><u>1234</u></mark>5|
|`{m,n}`|От m до n повторений включительно|`\d{2,4}`|1, <mark><u>12</u></mark>, <mark><u>123</u></mark>, <mark><u>1234</u></mark>, <mark><u>1234</u></mark>5|
|`{m,}`|Не менее m повторений|`\d{3,}`|1, 12, <mark><u>123</u></mark>, A<mark><u>1234</u></mark>, <mark><u>12345</u></mark>|
|`{,n}`|Не более n повторений|`\d{,2}`|<mark><u>1</u></mark>, <mark><u>12</u></mark>, <mark><u>12</u></mark>3|
|`?`|Ноль или одно вхождение,<br>синоним `{0,1}`|`валы?`|<mark><u>вал</u></mark>, <mark><u>валы</u></mark>, <mark><u>вал</u></mark>ов|
|`*`|Ноль или более,<br>синоним `{0,}`|`СУ\d*`|<mark><u>СУ</u></mark>, 100<mark><u>СУ1</u></mark>, <mark><u>СУ555</u></mark>, А<mark><u>СУ</u></mark>БМ|
|`+`|Одно или более,<br>синоним `{1,}`|`a\)+`|aba, <mark><u>a)</u></mark>, <mark><u>a))</u></mark>, <mark><u>a)))</u></mark>, b<mark><u>a)</u></mark>])|
|`*?`<br>`+?`<br>`??`<br>`{m,n}?`<br>`{,n}?`<br>`{m,}?`|По умолчанию квантификаторы _жадные_ — захватывают максимально возможное число символов.<br>Добавление `?` делает их _ленивыми_, они захватывают минимально возможное число символов|`h.*h`<br><br><br>`h.*?h`|<mark><u>haaassshhhoooeeeh</u></mark><br><br><br><mark><u>haaasssh</u></mark>h<mark><u>hoooeeeh</u></mark>|


### Группы и перечисления

|Шаблон|Описание|Пример|Применяем к тексту|
|---|---|---|---|
|&VerticalSeparator;|Перечисление|`белый`&VerticalSeparator;`синий`|На Мише был <mark><u>белый</u></mark> свитер и <mark><u>синий</u></mark> галстук|
|`(...)`|Группа с захватом. Группирует содержимое для обработки как единое целое и присваивает группе порядковый номер|`(\d\d-){2}\d\d`|<mark><u>22-35-14</u></mark> 223514 22-3514 2235-14|
|||`(Mr`&VerticalSeparator;`Ms`&VerticalSeparator;`Mrs).\w+`|Dr.Alex, <mark><u>Mr.White</u></mark>, <mark><u>Mrs.Anna</u></mark>|
|`\number`|Обратная ссылка на группу по ее порядковому номеру|`([aA])([bB])C\2\1`|abCBa, <mark><u>AbCbA</u></mark>, <mark><u>abCba</u></mark>, <mark><u>aBCBa</u></mark>, aBCbA
|`(?:...)`|Группа без захвата. Не присваивает группе порядковый номер<br>(экономия порядковых номеров)|||
|`(?P<name>...)`|Именованная группа с захватом. Одновременно с порядковым номером присваивается имя группы|`<(?P<tag>[hH][1-6])>\w+<(?P=tag)>`|<mark><u>&lt;H1&gt;Заголовок&lt;/H1&gt;</u></mark><br>&lt;h2&gt;Заголовок&lt;/h3&gt;|
|`(?P=name)`|Обратная ссылка на именованную группу|пример использования выше||



### Местоположение

|Шаблон|Описание|Пример|Применяем к тексту|
|---|---|---|---|
|`\b`|Начало или конец слова (слева пусто или не-буква, справа буква и наоборот).<br>В отличие от `\W` соответствует позиции, а не символу|`\bвал`|<mark><u>вал</u></mark>, перевал, Перевалка|
|`\B`|Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы|`\Bвал`|пере<mark><u>вал</u></mark>, вал, Пере<mark><u>вал</u></mark>ка|
|||`\bвал\b` - похоже на `\Wвал\W` но не требует символ (актуально для начала, конца строки)|перевал, <mark><u>вал</u></mark>, Перевалка|
|||`\Bвал\B` - похоже на `\wвал\w` но не требует символ (актуально для перекрывающихся позиций)|перевал, о<mark><u>вал</u></mark>ы|
|`^`|Начало предложения. Если включен флаг `MULTILINE`, то происходит сравнение и для каждой части после символа новой строки `\n`<br>См. [Флаги](#Флаги)|`^[сС]аш.`|<mark><u>Саша</u></mark> позвал Сашу|
|`\A`|Аналог `^` игнорирующий настройку `MULTILINE`|||
|`$`|Конец предложения. Если включен флаг `MULTILINE`, то происходит сравнение и для каждой части перед символом новой строки `\n`<br>См. [Флаги](#Флаги)|`[сС]аш.$`|Саша позвал <mark><u>Сашу</u></mark>|
|`\Z`|Аналог `$` игнорирующий настройку `MULTILINE`|||


## Флаги
***
|**Короткое имя**|**Полное имя**|**Назначение**|
|---|---|---|
|`re.I`| `re.IGNORECASE`|игнорирует регистр символов|
|`re.M`| `re.MULTILINE`|используется совместно с метасимволами `^` и `$`, в первом случае возвращает совпадения в начале каждой новой строки `\n`, во втором – в конце `\n`|
|`re.S`|`re.DOTALL`|заставляет метасимвол `.` возвращать совпадения по абсолютно всем символам, включая `\n`|
|`re.X`|`re.VERBOSE`|разрешает комментарии в регулярном выражении<br>[почитать подробнее](#re%20VERBOSE)|
|`-`|`re.DEBUG`|показывает отладочную информацию о скомпилированном регулярном выражении|
|`re.A`|`re.ASCII`|указывает кодировку ASCII для классификации символов `\w, \W, \b, \B, \d, \D, \s, \S`|
|`re.U`|`re.UNICODE`|указывает кодировку Unicode для классификации символов  `\w, \W, \b, \B, \d, \D, \s, \S`|
|`re.L`|`re.LOCALE`|учитывает региональные настройки при использовании метасимволов `\w, \W, \b, \B, \s, \S`|

### Комбинация флагов

Мы можем использовать несколько флагов одновременно. Для этого нужно использовать оператор `|`.

Приведенный ниже код:

```python
import re

match = re.search('^bar', 'FOO\nBAR\nBAZ', re.IGNORECASE | re.MULTILINE)

print(match)
```

выводит:

```no-highlight
<re.Match object; span=(4, 7), match='BAR'>
```

Оба флага `IGNORECASE` и `MULTILINE` были отработаны.


### `re.VERBOSE`:
с использованием флага `re.VERBOSE` можно записать в виде:

```python
import re

match = re.search('''\d +  # целая часть
                     \.    # десятичная точка
                     \d *  # дробная часть''', 'Десятичное число равно 123.7', re.VERBOSE)

print(match)
```


## Класс `Match`
***
- [Match.end()](#Match%20end) - последняя позиция среза найденной строки
- [Match.group()](#Match%20group) - возвращает содержимое групп с захватом или всю строку
- [Match.groups()](#Match%20groups) - возвращает кортеж с захваченными группами
- [Match.groupdict()](#Match%20groupdict) - возвращает словарь с захваченными именованными группами
- [Match.span()](#Match%20span) - возвращает кортеж (start(), end())
- [Match.start()](#Match%20start) - первая позиция среза найденной строки


### `Match.end()`: 

Методы `start()` и `end()` возвращают индексы начала и конца подстроки, которая совпала с регулярным выражением.

В методы `start()` и `end()` можно передать номер или названия группы. В этом случае методы вернут индексы начала и конца подстроки, совпадающей с нужной группой

Если некоторая группа соответствует строке нулевой длины, то значения возвращаемые методами `start()` и `end()` будут равны. Достаточно разумное поведение, учитывая, что значения, возвращаемые методами `start()` и `end()` действуют как индексы среза. Любой срез строки, в котором начальный и конечный индексы равны, всегда будет пустой строкой.

Приведенный ниже код:

```python
from re import search

text = 'foo123bar456baz'

match = search('(\d+)\D+(?P<num>\d+)baz(\d*)', text)

print(match)
print(match.group(), match.start(), match.end())
print(match.group(1), match.start(1), match.end(1))
print(match.group('num'), match.start('num'), match.end('num'))
print(match.start(2), match.end(2))
```

выводит:

```no-highlight
<re.Match object; span=(3, 15), match='123bar456baz'>
123bar456baz 3 15
123 3 6
456 9 12
15 15
```

Особый случай возникает, когда регулярное выражение содержит группу, не участвующую в сопоставлении. В этом случае оба метода вернут значение -1−1.

```python
from re import search

match = search('(\w+),(\w+),(\w+)?', 'foo,bar,')

print(match.group(3))                # None
print(match.start(3), match.end(3))  # -1 -1
```


### `Match.group()`:

Метод `group()` возвращает одну или несколько подгрупп совпадения. Если метод вызывается без аргументов, то возвращается вся подстрока, которая совпала с шаблоном регулярного выражения.

Если мы пользуемся **именованными группами**, используя синтаксис `(?P<name><regex>)`, тогда мы можем использовать название группы в качестве аргумента метода `group()`

по номерам групп:

```python
from re import search

match = search('(\w+),(\w+),(\w+)', 'foo,bar,baz')

print(match.group())           # вся строка    # foo,bar,baz
print(match.group(0))          # вся строка    # foo,bar,baz
print(match.group(1))          # подгруппа     # foo
print(match.group(2))          # подгруппа     # bar
print(match.group(3))          # подгруппа     # baz
print(match.group(1, 3, 2, 1)) # кортеж        # ('foo', 'baz', 'bar', 'foo')
```

по именам групп:

```python
from re import search

match = search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)', 'foo,bar,baz')

print(match.group())                       # foo,bar,baz
print(match.group('w1'))                   # foo
print(match.group('w2'))                   # bar
print(match.group('w3'))                   # baz
print(match.group('w1', 'w2', 'w3', 'w2')) # ('foo', 'bar', 'baz', 'bar')
```


### `Match.groups()`:

Метод `groups()` возвращает кортеж, содержащий все захваченные группы.

Группы, которые не смогли захватить какой-либо результат, по умолчанию будут иметь значение `None`. Если в такой ситуации требуется вернуть, значение отличное от `None`, то используется необязательный аргумент `default`.

Приведенный ниже код:

```python
from re import search

match = search('(\w+),(\w+),(\w+)?', 'foo,bar,')

print(match.groups(-1))               # позиционный аргумент
print(match.groups(''))
print(match.groups(default='----'))   # именованный аргумент
print(match.groups(default=False))
```

выводит:

```no-highlight
('foo', 'bar', -1)
('foo', 'bar', '')
('foo', 'bar', '----')
('foo', 'bar', False)
```

### `Match.groupdict()`:

Метод `groupdict()` возвращает словарь, содержащий все захваченные именованные группы.

Метод `groupdict()`, как и метод `groups()`, принимает необязательный аргумент `default`, который используется для указания значений групп, которые не смогли захватить какой либо результат. По умолчанию значение данного аргумента равно `None`.

Приведенный ниже код:

```python
from re import search

match = search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)?', 'foo,bar,')

print(match.groupdict())
print(match.groupdict(default=''))
print(match.groupdict(default='----'))
```

выводит:

```no-highlight
{'w1': 'foo', 'w2': 'bar', 'w3': None}
{'w1': 'foo', 'w2': 'bar', 'w3': ''}
{'w1': 'foo', 'w2': 'bar', 'w3': '----'}
```


### `Match.span()`:

Метод `span()` возвращает индексы начала и конца подстроки в виде кортежа, которая совпала с регулярным выражением. В метод `span()` также можно передать номер или название группы. В этом случае метод вернет индексы начала и конца подстроки в виде кортежа, совпадающей с нужной группой.

Метод `span()` предоставляет удобный способ получить как начальный, так и конечный индексы подстроки, которая совпала с регулярным выражением. Метод `span()` возвращает кортеж вида  `(start(), end())`.

Приведенный ниже код:

```python
from re import search

match = search('(\d+)\D+(?P<num>\d+)', 'foo123bar456baz')

print(match)              # <re.Match object; span=(3, 12), match='123bar456'>
print(match.span())       # (3, 12)
print(match.span(1))      # (3, 6)
print(match.span('num'))  # (9, 12)
```


### `Match.start()`: 

Методы `start()` и `end()` возвращают индексы начала и конца подстроки, которая совпала с регулярным выражением.

В методы `start()` и `end()` можно передать номер или названия группы. В этом случае методы вернут индексы начала и конца подстроки, совпадающей с нужной группой

Если некоторая группа соответствует строке нулевой длины, то значения возвращаемые методами `start()` и `end()` будут равны. Достаточно разумное поведение, учитывая, что значения, возвращаемые методами `start()` и `end()` действуют как индексы среза. Любой срез строки, в котором начальный и конечный индексы равны, всегда будет пустой строкой.

Приведенный ниже код:

```python
from re import search

text = 'foo123bar456baz'

match = search('(\d+)\D+(?P<num>\d+)baz(\d*)', text)

print(match)
print(match.group(), match.start(), match.end())
print(match.group(1), match.start(1), match.end(1))
print(match.group('num'), match.start('num'), match.end('num'))
print(match.start(2), match.end(2))
```

выводит:

```no-highlight
<re.Match object; span=(3, 15), match='123bar456baz'>
123bar456baz 3 15
123 3 6
456 9 12
15 15
```

Особый случай возникает, когда регулярное выражение содержит группу, не участвующую в сопоставлении. В этом случае оба метода вернут значение -1−1.

```python
from re import search

match = search('(\w+),(\w+),(\w+)?', 'foo,bar,')

print(match.group(3))                # None
print(match.start(3), match.end(3))  # -1 -1
```



## Методы модуля `re`
***

|   |   |
|---|---|
|**[escape(pattern)](#escape%20pattern)**|Экранирование спец.символов в обычной строке| 
|**[findall(pattern, string, flags=0)](#findall%20pattern%20string%20flags%200)**|поиск всех вхождений с отбором и группировкой в кортежи по группам захвата|
|**[finditer(pattern, string, flags=0)](#finditer%20pattern%20string%20flags%200)**|возвращает итератор совпадений в формате [Match](#Класс%20Match)|
|**[fullmatch(pattern, string, flags=0)](#fullmatch%20pattern%20string%20flags%200)**|проверка на совпадение шаблона `pattern` и строки `string`<br>возвращает [Match](#Класс%20Match)|
|**[match(pattern, string, flags=0)](#match%20pattern%20string%20flags%200)**|поиск шаблона `pattern` в начале строки `string`<br>возвращает [Match](#Класс%20Match)|
|**[search(pattern, string, flags=0)](#search%20pattern%20string%20flags%200)**|поиск первого совпадения шаблона `pattern` в строке `string`<br>возвращает [Match](#Класс%20Match)|
|**[split(pattern, string, maxsplit=0, flags=0)](#split%20pattern%20string%20maxsplit%200%20flags%200)**|Возвращает список строк разделенных по шаблону `pattern`|
|**[sub(pattern, repl, string, count=0, flags=0)](#sub%20pattern%20repl%20string%20count%200%20flags%200)**|Замена. Возвращает новую строку с замененными частями согласно шаблону `pattern` на текст или значение функции `repl`|
|**[subn(pattern, repl, string, count=0, flags=0)](#subn%20pattern%20repl%20string%20count%200%20flags%200)**|Идентична `sub()`. отличается возвращаемым значением|




### `compile()`:

Модуль `re` поддерживает возможность предварительной компиляции регулярного выражения в специальный объект, который можно повторно использовать позже. Для этого используется функция `compile()`.

Аргументы функции:

-   `regex` — шаблон регулярного выражения
-   `flags=0` — один или несколько флагов (необязательный аргумент)

Существует два способа использования скомпилированного объекта регулярного выражения.

**1 способ:** мы можем его указать в качестве первого аргумента для функций модуля `re`, вместо шаблона регулярного выражения.

Приведенный ниже код:

```python
import re

regex_obj = re.compile('\d+')
text = 'ул. Часовая, дом № 25, корпус 2, квартира 69'
result = re.findall(regex_obj, text)

print(result)
```

выводит:

```no-highlight
['25', '2', '69']
```


### `escape(pattern)`:

Функция `escape()` выполняет экранирование специальных символов в строке. Это полезно в ситуациях, когда регулярное выражение представляет из себя простую строку, которая может содержать метасимволы.

Аргументы функции:

-   `pattern` — шаблон регулярного выражения

Приведенный ниже код:

```python
from re import escape

print(escape('http://www.stepik.org'))
```

выводит:

```no-highlight
http://www\.stepik\.org
```

Функция `escape()` выполнила экранирование символа точки `.`.

Приведенный ниже код:

```python
from re import escape

operators = ['+', '-', '*', '/', '**']
print(','.join(map(escape, operators)))
```

выводит:

```no-highlight
\+,\-,\*,/,\*\*
```

Функция `escape()` выполнила экранирование всех арифметических операторов, кроме `/`


### `findall(pattern, string, flags=0)`:

Функция `findall()` возвращает все неперекрывающиеся совпадения с регулярным выражением в виде списка строк. Строка сканируется слева направо, и совпадения возвращаются в найденном порядке.

Аргументы функции:

-   `pattern` — шаблон регулярного выражения
-   `string` — строка для поиска
-   `flags=0` — один или несколько флагов (необязательный аргумент)

 Приведенный ниже код:

```python
import re

text = 'ул. Часовая, дом № 25, корпус 2, квартира 69'
result = re.findall('\d+', text)

print(result)
```

выводит:

```no-highlight
['25', '2', '69']
```

Если регулярное выражение содержит одну группу, то функция `findall()` вернет список соответсвующих групп, а не список полных совпадений с регулярным выражением.

```python
import re

result = re.findall('#(\w+)#', '#foo#.#bar#.#baz#')

print(result)
```

выводит:

```no-highlight
['foo', 'bar', 'baz']
```

В этом примере регулярному выражению `#(\w+)#` соответствуют строки `#foo#`, `#bar#` и `#baz#`. Но символы решетки (`#`) не отображаются в возвращаемом списке, потому что они находятся за пределами групп.

Если регулярное выражение содержит несколько групп, то функция `findall()` вернет список кортежей, каждый из которых содержит захваченные группы. При этом длина каждого кортежа равна указанному количеству групп.

Приведенный ниже код:

```python
import re

result1 = re.findall('(\w+),(\w+)', 'foo,bar,baz,qux,quux,corge')
result2 = re.findall('(\w+),(\w+),(\w+)', 'foo,bar,baz,qux,quux,corge')

print(result1)
print(result2)
```

выводит:

```no-highlight
[('foo', 'bar'), ('baz', 'qux'), ('quux', 'corge')]
[('foo', 'bar', 'baz'), ('qux', 'quux', 'corge')]
```

Обратите внимание на то, что группы, которые не смогли захватить какой-либо результат, также включаются в результирующий список.

Приведенный ниже код:

```python
import re

result = re.findall('(\w+),(\w+),(\w+)?', 'foo,bar,')

print(result)
```

выводит:

```no-highlight
[('foo', 'bar', '')]
```


### `finditer(pattern, string, flags=0)`:
#итератор

Функция `finditer()` возвращает все неперекрывающиеся совпадения с регулярным выражением в виде итератора, содержащего объекты соответствия (тип `Match`). Строка сканируется слева направо, и совпадения возвращаются в найденном порядке.

Аргументы функции:

-   `pattern` — шаблон регулярного выражения
-   `string` — строка для поиска
-   `flags=0` — один или несколько флагов (необязательный аргумент)

 Приведенный ниже код:

```python
import re

text = 'ул. Часовая, дом № 25, корпус 2, квартира 69'
result = re.finditer('\d+', text)

print(type(result))
print(list(result))
```

выводит:

```no-highlight
<class 'callable_iterator'>
[<re.Match object; span=(19, 21), match='25'>, <re.Match object; span=(30, 31), match='2'>, <re.Match object; span=(42, 44), match='69'>]
```


### `fullmatch(pattern, string, flags=0)`:

Функция `fullmatch()` возвращает специальный объект соответствия (тип [Match](#Класс%20Match)), если **вся строка** соответствует регулярному выражению, или значение `None` в противном случае.

Аргументы функции:

-   `pattern` — шаблон регулярного выражения
-   `string` — строка для поиска
-   `flags=0` — один или несколько флагов (необязательный аргумент)

Приведенный ниже код:

```python
from re import fullmatch

match1 = fullmatch('\d+', '123foo')
match2 = fullmatch('\d+', 'foo123')
match3 = fullmatch('\d+', 'foo123bar')
match4 = fullmatch('\d+', '123')

print(match1)
print(match2)
print(match3)
print(match4)
```

выводит:

```no-highlight
None
None
None
<re.Match object; span=(0, 3), match='123'>
```

### `match(pattern, string, flags=0)`:

Функция `match()` возвращает специальный объект соответствия (тип [Match](#Класс%20Match)), если **начало строки** соответствуют регулярному выражению, или значение `None` в противном случае.

Аргументы функции:

-   `pattern` — шаблон регулярного выражения
-   `string` — строка для поиска
-   `flags=0` — один или несколько флагов (необязательный аргумент)

Приведенный ниже код:

```python
from re import match

match1 = match('super', 'superstition')
match2 = match('super', 'insuperable')

print(match1)
print(match2)
```

выводит:

```no-highlight
<re.Match object; span=(0, 5), match='super'>
None
```


### `search(pattern, string, flags=0)`:

Функция `search()` сканирует строку в поисках **первого совпадения** с регулярным выражением и возвращает специальный объект соответствия (тип [Match](#Класс%20Match)) или значение `None`, если ни одна позиция в строке не соответствует регулярному выражению. 

Аргументы функции:

-   `pattern` — шаблон регулярного выражения
-   `string` — строка для поиска
-   `flags=0` — один или несколько флагов (необязательный аргумент)

 Приведенный ниже код:

```python
from re import search

match1 = search('super', 'superstition')
match2 = search('super', 'insuperable')
match3 = search('super', 'without')

print(match1)
print(match2)
print(match3)
```

выводит:

```no-highlight
<re.Match object; span=(0, 5), match='super'>
<re.Match object; span=(2, 7), match='super'>
None
```


### `split(pattern, string, maxsplit=0, flags=0)`:
Функция `re.split()` разбивает строку на подстроки, используя регулярное выражение в качестве разделителя, и возвращает подстроки в виде списка.

Если шаблон регулярного выражения содержит группы захвата, то возвращаемый список помимо подстрок также включает в себя эти группы.

Аргументы функции:

-   `pattern` — шаблон регулярного выражения
-   `string` — строка для поиска
-   `maxsplit=0` — максимальное количество разбиений (необязательный аргумент). Оставшиеся неразбитые строки добавляются в последнее значение результирующего списка
-   `flags=0` — один или несколько флагов (необязательный аргумент)

Приведенный ниже код:

```python
import re

result = re.split(r'[,;.]', 'foo,bar.baz;qux;stepik,beegeek')

print(result)
```

разбивает строку на подстроки, используя в качестве разделителя один из трех символов `,`, `;` или `.`, и выводит:

```no-highlight
['foo', 'bar', 'baz', 'qux', 'stepik', 'beegeek']
```



### `sub(pattern, repl, string, count=0, flags=0)`:

Функция `sub()` возвращает строку, полученную путем замены крайнего левого неперекрывающегося вхождения регулярного выражения `pattern` в строке `string` на строку замены `repl`.

Аргументы функции:
-   `pattern` — шаблон регулярного выражения
-   `repl` — строка замены
-   `string` — строка для поиска
-   `count=0` — максимальное число замен (необязательный аргумент)
-   `flags=0` — один или несколько флагов (необязательный аргумент)

Если шаблон регулярного выражения не найден, строка возвращается без изменений.

Аргумент `repl` может быть строкой или функцией. Если `repl` это строка, то в ней обрабатываются все обратные слеши, то есть `\n` преобразуется в символ новой строки, `\r` преобразуется в возврат каретки и т. д.

#### Замена строкой
```python
import re

text = 'Java самый популярный язык программирования в 2022 году.'

res = re.sub(r'Java', r'Python', text)

print(res)  # Python самый популярный язык программирования в 2022 году.
```


При использовании функции `sub()` можно использовать пронумерованные обратные ссылки (`\<n>`) в аргументе `repl`, которым будет соответствовать текст захваченной группы. Обратные ссылки, такие как `\2`, заменяются подстрокой, соответствующей группе №2 в шаблоне регулярного выражения.

```python
import re

result = re.sub(r'(\w+),bar,baz,(\w+)', r'\2,bar,baz,\1', r'foo,bar,baz,qux')

print(result)  # qux,bar,baz,foo
```

также можно ссылаться на нумерованные обратные ссылки, указывая номер группы внутри угловых скобок.

Приведенный ниже код:

```python
import re

result = re.sub(r'foo,(\w+),(\w+),qux', r'foo,\g<2>,\g<1>,qux', 'foo,bar,baz,qux')

print(result)  # foo,baz,bar,qux
```

Также можно использовать именованные обратные ссылки, созданные с помощью уже знакомого нам синтаксиса `(?P<name><regex>)` в строке замены, используя последовательность метасимволов `\g<name>`.

Приведенный ниже код:

```python
import re

result = re.sub(r'foo,(?P<w1>\w+),(?P<w2>\w+),qux', r'foo,\g<w2>,\g<w1>,qux', r'foo,bar,baz,qux')

print(result)   # foo,baz,bar,qux
```

#### Замена функцией
Функция, передаваемая в качестве аргумента `repl`, должна принимать один аргумент — объект соответствия (тип `Match`) и возвращать строку замены.

Если в качестве аргумента `repl` использовать функцию, то функция `sub()` вызовет эту функцию для каждого найденного совпадения. Она передает каждый соответствующий объект совпадения (тип `Match`) в качестве аргумента функции для предоставления информации о совпадении, при этом возвращаемое из функции значение становится строкой замены.

Приведенный ниже код:

```python
import re
def func(match_obj):
    s = match_obj.group(0)         # строка совпадения
    if s.isdigit():
        return str(int(s) * 10)
    else:
        return s.upper()

result = re.sub(r'\w+', func, r'foo.10.bar.20.baz30.40')

print(result)   # FOO.100.BAR.200.BAZ30.400
```


### `subn(pattern, repl, string, count=0, flags=0)`:

Функция `subn()` идентична функции [sub()](#sub%20pattern%20repl%20string%20count%200%20flags%200), за тем исключением, что она возвращает кортеж, состоящий из измененной строки и количества сделанных замен.

Аргументы функции:
-   `pattern` — шаблон регулярного выражения
-   `repl` — строка замены
-   `string` — строка для поиска
-   `count=0` — максимальное число замен (необязательный аргумент)
-   `flags=0` — один или несколько флагов (необязательный аргумент)

```python
import re
def func(match_obj):
    s = match_obj.group(0)         # строка совпадения
    if s.isdigit():
        return str(int(s) * 10)
    else:
        return s.upper()

result = re.subn(r'\w+', func, 'foo.10.bar.20.baz30.40')

print(result)   # ('FOO.100.BAR.200.BAZ30.400', 6)
```

