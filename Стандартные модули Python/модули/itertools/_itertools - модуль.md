# Модуль `itertools`
#itertools #итераторы
***
## Классы и методы модуля `itertools`
***
### Бесконечные итераторы
|      |      |
|----|----|
|**[count(start, step)](#count%20start%200%20step%201)**|итератор чисел|
|**[islice(iterator)](#islice%20iterator)**|ограничитель бесконечного итератора|
|**[cycle(iterable)](#cycle%20iterable)**|цикличный итератор последовательности|
|**[repeat(obj, times=None)](#repeat%20obj%20times%20None)**|итератор возвращает одинаковое значение|

### Конечные итераторы
|   |   |
|---|---|
|**[accumulate(iterable, func, initial)](#accumulate%20iterable%20func%20initial)**|аналог `reduce()` возвращающий в т.ч. промежуточные результаты|
|**[chain(\*iterable)](#chain%20iterable)**|итератор из цепочки итерируемых объектов|
|**[chain.from_iterable(iterable)](#chain%20from_iterable%20iterable)**|итератор из итерируемого объекта, содержащего вложенные итерируемые объекты|
|**[compress(iterable, selectors)](#compress%20iterable%20selectors)**|фильтр по маске логических значений|
|**[dropwhile(predicate, iterable)](#dropwhile%20predicate%20iterable)**|итератор значений, следующих после первого появление ложного результата условия `predicate`  (итератор не выдает значения, пока all(predicate = True)|
|**[pairwise()](#pairwise)**|итератор перекрывающихся пар значений итерируемого объекта|
|**[takewhile(predicate, iterable)](#takewhile%20predicate%20iterable)**|итератор значений, предшествующих первому появлению ложного результата условия `predicate`|**[filterfalse(predicate, iterable)](#filterfalse%20predicate%20iterable)** - функция, обратная встроенной `filter()`
- **groupby()**
- **[starmap(function, iterable1, \[iterable2\])](#starmap%20function%20iterable1%20iterable2)** - аналог map() умеющий работать с вложенными последовательностями
- **[tee()](#tee)** - размножение итераторов
- **[zip_longest(\*iterables)](#zip_longest%20iterables)** - аналог `zip()` для объединения последовательностей разной длины

### Комбинаторные итераторы
- **combinations()**
- **combinations_with_replacement()**
- **product()**
- **permutations()**


### `accumulate(iterable, func, initial)`:
Функция `accumulate()` возвращает итератор, элементами которого являются накопленные суммы или накопленные результаты функции `func`.

Аргументы функции:
-   `iterable` — итерируемый объект
-   `func` — функция, принимающая два аргумента, по умолчанию используется функция сложения `operator.add`
-   `initial` — начальное значение, по умолчанию имеет значение `None`

Функция работает аналогично функции `reduce()` за тем исключением, что функция `accumulate()` генерирует все промежуточные результаты, а не только конечный.


### `chain(*iterable)`:

Функция `chain()` возвращает итератор, который последовательно генерирует элементы всех переданных итерируемых объектов.

Аргументы функции:
-   `*iterables` — итерируемые объекты

Функция `chain()` упрощает обработку нескольких итерируемых объектов, не требуя предварительного конструирования объединенного списка.

### `chain.from_iterable(iterable)`:

Функция `chain.from_iterable()` принимает в качестве аргумента итерируемый объект, содержащий другие итерируемые объекты и возвращает итератор, который генерирует элементы всех вложенных итерируемых объектов.

Аргументы функции:

-   `iterable` — итерируемый объект, содержащий другие итерируемые объекты

Приведенный ниже код:

```python
from itertools import chain

chain_iter1 = chain.from_iterable(['ABC', 'DEF'])      # передаем список
print(*chain_iter1)

chain_iter2 = chain.from_iterable(enumerate('ABC'))
print(*chain_iter2)

for i in chain.from_iterable(['Timur', '29', 'Male', 'Teacher']):
    print(i, end=' ')
```

выводит:

```no-highlight
A B C D E F
0 A 1 B 2 C
T i m u r 2 9 M a l e T e a c h e r 
```


### `compress(iterable, selectors)`:
Функция `compress()` предлагает другой способ фильтрации содержимого итерируемого объекта. Вместо того чтобы вызывать функцию, она использует значения другого итерируемого объекта для индикации того, следует ли принять значение или игнорировать его.

Аргументы функции:
-   `iterable` — итерируемый объект
-   `selectors` — итерируемый объект, состоящий из значений `True, False`, который предоставляет значения, указывающие на то, какие входные значения следует брать, а какие следует игнорировать

Приведенный ниже код:


### `count(start=0, step=1)`:
Возвращает бесконечный итератор чисел, начиная с `start` с шагом `step`
Аргументами могут быть любые числовые значения, допускающие операцию сложения


### `cycle(iterable)`:
Возвращает итератор, циклично генерирующий последовательность элементов переданного итерируемого объекта

Для выполнения функции `cycle()` может потребоваться значительное количество дополнительной памяти в зависимости от длины `iterable` так как для повторения цикла значения после первого прохода сохраняются в памяти!

### `dropwhile(predicate, iterable)`:
Функция `dropwhile()` возвращает итератор, который генерирует элементы входного итерируемого объекта сразу же после того, как для заданного условия будет получено ложное значение. Содержимое, предшествующее ложному значению условия отбрасывается. (итератор не выдает значения, пока all(predicate = True)

Аргументы функции:
-   `predicate` — фильтрующая функция, возвращающая `bool` значение
-   `iterable` — итерируемый объект


### `filterfalse(predicate, iterable)`:

Функция `filterfalse()` возвращает итератор, который генерирует элементы из входного итерируемого объекта для которых заданное условие ложно. По сути, действия функции `filterfalse()` противоположны действиям встроенной функции `filter()`.

Аргументы функции:
-   `predicate` — фильтрующая функция, возвращающая `bool` значение
-   `iterable` — итерируемый объект


### `islice(iterator)`:
Позволяет ограничить бесконечный итератор ограниченным количеством итераций или создать итератор из итерируемого объекта

#### Синтаксис:

```python
import itertools

itertools.islice(iterable, stop)
itertools.islice(iterable, start, stop[, step])
```

**Аргументы функции:**
-   `iterable` — итерируемый объект
-   `start` — начало среза, по умолчанию имеет значение 0
-   `stop` — конец среза (не включительно). значение None - без ограничений
-   `step` — шаг среза, по умолчанию имеет значение 1

В отличие от обычных срезов списков (строк, кортежей), функция `islice()` не поддерживает отрицательные значения для `start`, `stop` или `step`.

```python
from itertools import islice, count
for i in islice(count(10), 5):   # ограничение на 5 итераций
     print(i)
```


### `pairwise()`:

Функция `pairwise()` возвращает итератор, содержащий последовательные перекрывающиеся пары в виде кортежей, взятые из исходного итерируемого объекта.

Аргументы функции:

-   `iterable` — итерируемый объект

Приведенный ниже код:

```python
from itertools import pairwise

print(*pairwise('ABCDEFG'))
print(*pairwise([1, 2, 3, 4, 5]))
```

выводит:

```no-highlight
('A', 'B') ('B', 'C') ('C', 'D') ('D', 'E') ('E', 'F') ('F', 'G')
(1, 2) (2, 3) (3, 4) (4, 5)
```


### `repeat(obj, times=None)`:
Итератор возращает значение `obj` `times`-количество раз. Если не указано, то бесконечно


### `starmap(function, iterable1, [iterable2])`:
Функция `starmap()` используется вместо `map()` в том случае, когда элементами итерируемого объекта являются другие итерируемые объекты, скажем, кортежи, и каждый элемент этих кортежей должен быть передан в функцию `function` в качестве самостоятельного аргумента

```python
from itertools import starmap 
persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')] 
pairs = [(1, 3), (2, 5), (6, 4)] 
points = [(1, 1, 1), (1, 1, 2), (2, 2, 3)]

full_names = list(starmap(lambda name, surname: f'{name} {surname}', persons)) 
# в отличие от map() starmap() умеет распаковывать последовательности

print(full_names) 
print(*starmap(lambda a, b: a + b, pairs)) 
print(*starmap(lambda x, y, z: x * y * z, points))
```


### `takewhile(predicate, iterable)`:
Функция `takewhile()` возвращает итератор, который генерирует элементы из входного итерируемого объекта до тех пор пока для заданного условия не будет получено ложное значение. По сути, действия функции `takewhile()` противоположны действиям функции `dropwhile()`.

Аргументы функции:
-   `predicate` — фильтрующая функция, возвращающая `bool` значение
-   `iterable` — итерируемый объект


### `tee()`:

Функция `tee()` позволяет создать несколько **независимых итераторов** на основе одного и того же итерируемого объекта. Возвращает кортеж итераторов

Аргументы функции:

-   `iterable` — итерируемый объект
-   `n` — количество создаваемых итераторов, по умолчанию имеет значение 2

Итераторы, возвращаемые функцией `tee()`, могут быть использованы c целью передачи одного и того же набора данных нескольким алгоритмам для их параллельной обработки.

### `zip_longest(*iterables)`:

Как мы уже знаем, встроенная функция `zip()` возвращает итератор, объединяющий элементы нескольких итерируемых объектов в кортежи. При этом функция `zip()` прекращает работу, как только исчерпывается самый короткий итерируемый объект. Чтобы обеспечить обработку всех входных элементов, когда итерируемые объекты имеют разные длины, используется функция `zip_longest()`.

Аргументы функции:
-   `*iterables` — итерируемые объекты
-   `fillvalue` — заполнитель, по умолчанию имеет значение `None`