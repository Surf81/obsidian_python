# Модуль `itertools`
#itertools #итераторы
***
## Классы и методы модуля `itertools`
***
### Бесконечные итераторы
|      |      |
|----|----|
|**[count(start, step)](#count%20start%200%20step%201)**|итератор чисел|
|**[islice(iterator)](#islice%20iterator)**|ограничитель бесконечного итератора|
|**[cycle(iterable)](#cycle%20iterable)**|цикличный итератор последовательности|
|**[repeat(obj, times=None)](#repeat%20obj%20times%20None)**|итератор возвращает одинаковое значение|

### Конечные итераторы
|   |   |
|---|---|
|**[accumulate(iterable, func, initial)](#accumulate%20iterable%20func%20initial)**|аналог `reduce()` возвращающий в т.ч. промежуточные результаты|
|**[chain(\*iterable)](#chain%20iterable)**|итератор из цепочки итерируемых объектов|
|**[chain.from_iterable(iterable)](#chain%20from_iterable%20iterable)**|итератор из итерируемого объекта, содержащего вложенные итерируемые объекты|
|**[compress(iterable, selectors)](#compress%20iterable%20selectors)**|фильтр по маске логических значений|
|**[dropwhile(predicate, iterable)](#dropwhile%20predicate%20iterable)**|итератор значений, следующих после первого появление ложного результата условия `predicate`  (итератор не выдает значения, пока all(predicate = True)|
|**[pairwise()](#pairwise%20iterable)**|итератор перекрывающихся пар значений итерируемого объекта|
|**[takewhile(predicate, iterable)](#takewhile%20predicate%20iterable)**|итератор значений, предшествующих первому появлению ложного результата условия `predicate`|**[filterfalse(predicate, iterable)](#filterfalse%20predicate%20iterable)** - функция, обратная встроенной `filter()`
|**[starmap(function, iterable1, \[iterable2\])](#starmap%20function%20iterable1%20iterable2)**|аналог map() умеющий работать с вложенными последовательностями|
|**[tee()](#tee)**|размножение итераторов|
|**[zip_longest(\*iterables)](#zip_longest%20iterables)**|аналог `zip()` для объединения последовательностей разной длины|

### Группирующие итераторы
|   |   |
|---|---|
 |**[groupby()](#groupby)**|группировка смежных элементов итерируемого объекта|


### Комбинаторные итераторы
- **combinations()**
- **combinations_with_replacement()**
- **product()**
- **[permutations(iterable, r)](#permutations%20iterable%20r)** - итератор перестановок элементов (при указанном `r` - размещений элементов)


### `accumulate(iterable, func, initial)`:
Функция `accumulate()` возвращает итератор, элементами которого являются накопленные суммы или накопленные результаты функции `func`.

Аргументы функции:
-   `iterable` — итерируемый объект
-   `func` — функция, принимающая два аргумента, по умолчанию используется функция сложения `operator.add`
-   `initial` — начальное значение, по умолчанию имеет значение `None`

Функция работает аналогично функции `reduce()` за тем исключением, что функция `accumulate()` генерирует все промежуточные результаты, а не только конечный.


### `chain(*iterable)`:

Функция `chain()` возвращает итератор, который последовательно генерирует элементы всех переданных итерируемых объектов.

Аргументы функции:
-   `*iterables` — итерируемые объекты

Функция `chain()` упрощает обработку нескольких итерируемых объектов, не требуя предварительного конструирования объединенного списка.

### `chain.from_iterable(iterable)`:

Функция `chain.from_iterable()` принимает в качестве аргумента итерируемый объект, содержащий другие итерируемые объекты и возвращает итератор, который генерирует элементы всех вложенных итерируемых объектов.

Аргументы функции:

-   `iterable` — итерируемый объект, содержащий другие итерируемые объекты

Приведенный ниже код:

```python
from itertools import chain

chain_iter1 = chain.from_iterable(['ABC', 'DEF'])      # передаем список
print(*chain_iter1)

chain_iter2 = chain.from_iterable(enumerate('ABC'))
print(*chain_iter2)

for i in chain.from_iterable(['Timur', '29', 'Male', 'Teacher']):
    print(i, end=' ')
```

выводит:

```no-highlight
A B C D E F
0 A 1 B 2 C
T i m u r 2 9 M a l e T e a c h e r 
```


### `compress(iterable, selectors)`:
Функция `compress()` предлагает другой способ фильтрации содержимого итерируемого объекта. Вместо того чтобы вызывать функцию, она использует значения другого итерируемого объекта для индикации того, следует ли принять значение или игнорировать его.

Аргументы функции:
-   `iterable` — итерируемый объект
-   `selectors` — итерируемый объект, состоящий из значений `True, False`, который предоставляет значения, указывающие на то, какие входные значения следует брать, а какие следует игнорировать

Приведенный ниже код:


### `count(start=0, step=1)`:
Возвращает бесконечный итератор чисел, начиная с `start` с шагом `step`
Аргументами могут быть любые числовые значения, допускающие операцию сложения


### `cycle(iterable)`:
Возвращает итератор, циклично генерирующий последовательность элементов переданного итерируемого объекта

Для выполнения функции `cycle()` может потребоваться значительное количество дополнительной памяти в зависимости от длины `iterable` так как для повторения цикла значения после первого прохода сохраняются в памяти!

### `dropwhile(predicate, iterable)`:
Функция `dropwhile()` возвращает итератор, который генерирует элементы входного итерируемого объекта сразу же после того, как для заданного условия будет получено ложное значение. Содержимое, предшествующее ложному значению условия отбрасывается. (итератор не выдает значения, пока all(predicate = True)

Аргументы функции:
-   `predicate` — фильтрующая функция, возвращающая `bool` значение
-   `iterable` — итерируемый объект


### `filterfalse(predicate, iterable)`:

Функция `filterfalse()` возвращает итератор, который генерирует элементы из входного итерируемого объекта для которых заданное условие ложно. По сути, действия функции `filterfalse()` противоположны действиям встроенной функции `filter()`.

Аргументы функции:
-   `predicate` — фильтрующая функция, возвращающая `bool` значение
-   `iterable` — итерируемый объект


### `groupby()`:

Функция `groupby()` используется для группировки смежных элементов итерируемого объекта. Она возвращает итератор, содержащий **кортежи**, каждый из которых состоит из двух элементов: первый — значение, характеризующее группу, второй — итератор, содержащий элементы соответствующей группы.

Аргументы функции:
-   `iterable` — итерируемый объект
-   `key` — функция, вычисляющая значение, характеризующее группу

Если ключ `key` не указан или равен `None`, ключом по умолчанию является функция тождественности, которая возвращает элемент без изменений.

**Примечание:** Функция `groupby()` возвращает итератор, содержащий кортежи вида `(key, group)`, при этом `group` также является итератором. Важным является то, что, если мы получили итератор, содержащий элементы очередной группы, это значит, что все итераторы, содержащие элементы предшествующих групп, уже пусты.

Приведенный ниже код:

```python
from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers)

for key, values in group_iter:
    print(f'{key}: {list(values)}')            # преобразуем итератор в список
```

выводит:

```no-highlight
1: [1, 1, 1]
7: [7, 7, 7, 7]
15: [15]
7: [7, 7, 7]
```


Применение аргумента `key` у функции `groupby()`.

Приведенный ниже код:

```python
from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers, key=lambda num: num < 10)

for key, values in group_iter:
    print(f'{key}: {list(values)}')
```

выводит:

```no-highlight
True: [1, 1, 1, 7, 7, 7, 7]
False: [15]
True: [7, 7, 7]
```


### `islice(iterator)`:
Позволяет ограничить бесконечный итератор ограниченным количеством итераций или создать итератор из итерируемого объекта

#### Синтаксис:

```python
import itertools

itertools.islice(iterable, stop)
itertools.islice(iterable, start, stop[, step])
```

**Аргументы функции:**
-   `iterable` — итерируемый объект
-   `start` — начало среза, по умолчанию имеет значение 0
-   `stop` — конец среза (не включительно). значение None - без ограничений
-   `step` — шаг среза, по умолчанию имеет значение 1

В отличие от обычных срезов списков (строк, кортежей), функция `islice()` не поддерживает отрицательные значения для `start`, `stop` или `step`.

```python
from itertools import islice, count
for i in islice(count(10), 5):   # ограничение на 5 итераций
     print(i)
```


### `pairwise(iterable)`:

Функция `pairwise()` возвращает итератор, содержащий последовательные перекрывающиеся пары в виде кортежей, взятые из исходного итерируемого объекта.

Аргументы функции:

-   `iterable` — итерируемый объект

Приведенный ниже код:

```python
from itertools import pairwise

print(*pairwise('ABCDEFG'))
print(*pairwise([1, 2, 3, 4, 5]))
```

выводит:

```no-highlight
('A', 'B') ('B', 'C') ('C', 'D') ('D', 'E') ('E', 'F') ('F', 'G')
(1, 2) (2, 3) (3, 4) (4, 5)
```


### `permutations(iterable, r)`:
#перестановки

Функция `permutations()` возвращает итератор, который содержит все перестановки из элементов переданного итерируемого объекта. Каждая перестановка заключена в кортеж нужной длины.

Аргументы функции:

-   `iterable` — итерируемый объект
-   `r` — целое число, длина возвращаемых кортежей; по умолчанию имеет значение `None`

Если значение аргумента `r` не указано или равно `None`, тогда по умолчанию `r` равно длине итерируемого объекта `iterable`, и генерируются все возможные перестановки полной длины.

Элементы итерируемого объекта рассматриваются как уникальные в зависимости от их положения, а не от их значения. Поэтому, если элементы уникальны, повторных значений в каждой перестановке не будет. Если же не уникальны, то будут повторы
```python
import itertools as it
a = [1, 2, 3]

print(*it.permutations(a, 2))   # (1, 2) (1, 3) (2, 1) (2, 3) (3, 1) (3, 2)
```


### `repeat(obj, times=None)`:
Итератор возращает значение `obj` `times`-количество раз. Если не указано, то бесконечно


### `starmap(function, iterable1, [iterable2])`:
#map 

Функция `starmap()` используется вместо `map()` в том случае, когда элементами итерируемого объекта являются другие итерируемые объекты, скажем, кортежи, и каждый элемент этих кортежей должен быть передан в функцию `function` в качестве самостоятельного аргумента

```python
from itertools import starmap 
persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')] 
pairs = [(1, 3), (2, 5), (6, 4)] 
points = [(1, 1, 1), (1, 1, 2), (2, 2, 3)]

full_names = list(starmap(lambda name, surname: f'{name} {surname}', persons)) 
# в отличие от map() starmap() умеет распаковывать последовательности

print(full_names) 
print(*starmap(lambda a, b: a + b, pairs)) 
print(*starmap(lambda x, y, z: x * y * z, points))
```


### `takewhile(predicate, iterable)`:
Функция `takewhile()` возвращает итератор, который генерирует элементы из входного итерируемого объекта до тех пор пока для заданного условия не будет получено ложное значение. По сути, действия функции `takewhile()` противоположны действиям функции `dropwhile()`.

Аргументы функции:
-   `predicate` — фильтрующая функция, возвращающая `bool` значение
-   `iterable` — итерируемый объект


### `tee()`:

Функция `tee()` позволяет создать несколько **независимых итераторов** на основе одного и того же итерируемого объекта. Возвращает кортеж итераторов

Аргументы функции:

-   `iterable` — итерируемый объект
-   `n` — количество создаваемых итераторов, по умолчанию имеет значение 2

Итераторы, возвращаемые функцией `tee()`, могут быть использованы c целью передачи одного и того же набора данных нескольким алгоритмам для их параллельной обработки.

### `zip_longest(*iterables)`:

Как мы уже знаем, встроенная функция `zip()` возвращает итератор, объединяющий элементы нескольких итерируемых объектов в кортежи. При этом функция `zip()` прекращает работу, как только исчерпывается самый короткий итерируемый объект. Чтобы обеспечить обработку всех входных элементов, когда итерируемые объекты имеют разные длины, используется функция `zip_longest()`.

Аргументы функции:
-   `*iterables` — итерируемые объекты
-   `fillvalue` — заполнитель, по умолчанию имеет значение `None`