# Модуль `itertools`
#itertools #итераторы
***
## Классы и методы модуля `itertools`
***
### Бесконечные итераторы
- **[count(start, step)](#count%20start%200%20step%201)** - итератор чисел
- **[islice(iterator)](#islice%20iterator)** - ограничитель бесконечного итератора
- **[cycle(iterable)](#cycle%20iterable)** - цикличный итератор последовательности
- **[repeat(obj, times=None)](#repeat%20obj%20times%20None)** - итератор возвращает одинаковое значение

### Конечные итераторы
- **[accumulate(iterable, func, initial)](#accumulate%20iterable%20func%20initial)** - аналог `reduce()` возвращающий в т.ч. промежуточные результаты
- **chain**
- **[compress(iterable, selectors)](#compress%20iterable%20selectors)** - фильтр по маске логических значений
- **[dropwhile(predicate, iterable)](#dropwhile%20predicate%20iterable)** - итератор значений, следующих после первого появление ложного результата условия `predicate`  (итератор не выдает значения, пока all(predicate = True)
- **[takewhile(predicate, iterable)](#takewhile%20predicate%20iterable)** итератор значений, предшествующих первому появлению ложного результата условия `predicate`
- **[filterfalse(predicate, iterable)](#filterfalse%20predicate%20iterable)** - функция, обратная встроенной `filter()`
- **groupby()**
- **[starmap(function, iterable1, \[iterable2\])](#starmap%20function%20iterable1%20iterable2)** - аналог map() умеющий работать с вложенными последовательностями
- **tee()**
- **zip_longest()**

### Комбинаторные итераторы
- **combinations()**
- **combinations_with_replacement()**
- **product()**
- **permutations()**


### `accumulate(iterable, func, initial)`:
Функция `accumulate()` возвращает итератор, элементами которого являются накопленные суммы или накопленные результаты функции `func`.

Аргументы функции:
-   `iterable` — итерируемый объект
-   `func` — функция, принимающая два аргумента, по умолчанию используется функция сложения `operator.add`
-   `initial` — начальное значение, по умолчанию имеет значение `None`

Функция работает аналогично функции `reduce()` за тем исключением, что функция `accumulate()` генерирует все промежуточные результаты, а не только конечный.


### `compress(iterable, selectors)`:
Функция `compress()` предлагает другой способ фильтрации содержимого итерируемого объекта. Вместо того чтобы вызывать функцию, она использует значения другого итерируемого объекта для индикации того, следует ли принять значение или игнорировать его.

Аргументы функции:
-   `iterable` — итерируемый объект
-   `selectors` — итерируемый объект, состоящий из значений `True, False`, который предоставляет значения, указывающие на то, какие входные значения следует брать, а какие следует игнорировать

Приведенный ниже код:


### `count(start=0, step=1)`:
Возвращает бесконечный итератор чисел, начиная с `start` с шагом `step`
Аргументами могут быть любые числовые значения, допускающие операцию сложения


### `cycle(iterable)`:
Возвращает итератор, циклично генерирующий последовательность элементов переданного итерируемого объекта

Для выполнения функции `cycle()` может потребоваться значительное количество дополнительной памяти в зависимости от длины `iterable` так как для повторения цикла значения после первого прохода сохраняются в памяти!

### `dropwhile(predicate, iterable)`:
Функция `dropwhile()` возвращает итератор, который генерирует элементы входного итерируемого объекта сразу же после того, как для заданного условия будет получено ложное значение. Содержимое, предшествующее ложному значению условия отбрасывается. (итератор не выдает значения, пока all(predicate = True)

Аргументы функции:
-   `predicate` — фильтрующая функция, возвращающая `bool` значение
-   `iterable` — итерируемый объект


### `filterfalse(predicate, iterable)`:

Функция `filterfalse()` возвращает итератор, который генерирует элементы из входного итерируемого объекта для которых заданное условие ложно. По сути, действия функции `filterfalse()` противоположны действиям встроенной функции `filter()`.

Аргументы функции:
-   `predicate` — фильтрующая функция, возвращающая `bool` значение
-   `iterable` — итерируемый объект


### `islice(iterator)`:
Позволяет ограничить бесконечный итератор ограниченным количеством итераций или создать итератор из итерируемого объекта

#### Синтаксис:

```python
import itertools

itertools.islice(iterable, stop)
itertools.islice(iterable, start, stop[, step])
```

**Аргументы функции:**
-   `iterable` — итерируемый объект
-   `start` — начало среза, по умолчанию имеет значение 0
-   `stop` — конец среза (не включительно). значение None - без ограничений
-   `step` — шаг среза, по умолчанию имеет значение 1

В отличие от обычных срезов списков (строк, кортежей), функция `islice()` не поддерживает отрицательные значения для `start`, `stop` или `step`.

```python
from itertools import islice, count
for i in islice(count(10), 5):   # ограничение на 5 итераций
     print(i)
```


### `repeat(obj, times=None)`:
Итератор возращает значение `obj` `times`-количество раз. Если не указано, то бесконечно


### `starmap(function, iterable1, [iterable2])`:
Функция `starmap()` используется вместо `map()` в том случае, когда элементами итерируемого объекта являются другие итерируемые объекты, скажем, кортежи, и каждый элемент этих кортежей должен быть передан в функцию `function` в качестве самостоятельного аргумента

```python
from itertools import starmap 
persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')] 
pairs = [(1, 3), (2, 5), (6, 4)] 
points = [(1, 1, 1), (1, 1, 2), (2, 2, 3)]

full_names = list(starmap(lambda name, surname: f'{name} {surname}', persons)) 
# в отличие от map() starmap() умеет распаковывать последовательности

print(full_names) 
print(*starmap(lambda a, b: a + b, pairs)) 
print(*starmap(lambda x, y, z: x * y * z, points))
```


### `takewhile(predicate, iterable)`:
Функция `takewhile()` возвращает итератор, который генерирует элементы из входного итерируемого объекта до тех пор пока для заданного условия не будет получено ложное значение. По сути, действия функции `takewhile()` противоположны действиям функции `dropwhile()`.

Аргументы функции:
-   `predicate` — фильтрующая функция, возвращающая `bool` значение
-   `iterable` — итерируемый объект