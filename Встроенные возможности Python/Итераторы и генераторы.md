# Итераторы и генераторы
#итератор #генератор
***

>### [Стандартные итераторы](Встроенные%20функции/встроенные%20функции%20по%20назначению.md#Итераторы)

## Шаблон класса итератора
***
```python
class MyIterator:
    def __init__(self, *params):
        self.param1 = param1
        ...
        
	def __iter__(self):          # метод __iter__() возвращает самого себя
        return self              # для совместимости с for
    
    def __next__(self):
        if <условие>:
            raise StopIteration  # окончание работы итератора
            <вычисление результата>
        return <результат>

```

## Генераторы
#генератор 
-   любая функция, содержащая ключевое слово `yield`, является функцией генератором
-   когда вызывается функция генератор, то она **не возвращает единственное значение**, как это делает обыкновенная функция
-   функция генератор всегда возвращает объект типа `generator`, который поддерживает протокол итератора
- ключевой слово `return` в генераторе вызывает исключение `StopIteration`

Разница между `yield` и оператором `return` заключается в том, что для ключевого слова `yield` состояние выполнения генератора приостанавливается и локальные переменные сохраняются. При следующем вызове метода генератора `__next__()` функция возобновляет свое выполнение из той точки, из которой завершила в прошлый раз.

Генератор является итератором, поэтому он обладает всеми его особенностями:

-   нельзя получить длину генератора функцией `len()`
-   нельзя распечатать элементы генератора функцией `print()` без предварительной распаковки
-   у генератора нельзя получить элемент по индексу
-   после итерации по генератору он становится пустым

```python
def even_numbers(begin): 
	begin += begin % 2 
	while True: 
		yield begin 
		begin += 2
```