# Класс `str`
#str #строки #типданных 
***
## Методы `str`

- **[Методы поиска в строке](#Методы%20поиска%20в%20строке)**
	**[`find()`](#`find(sub[,%20start[,%20end%20)%20->%20int`)**
	**[`rfind()`](#`rfind()`)**
	**[`index()`](#`index(sub[,%20start[,%20end%20)%20->%20int`)**
	**[`rindex()`](#`rindex()`)**
	**[`count()`](#`count(sub[,%20start[,%20end%20)%20->%20int`)**
	**[`startswith()`](#`startswith(prefix[,%20start[,%20end%20)%20->%20bool`)**
	**[`endswith()`](#`endswith()`)**
	
- **[Методы разделения и соединения строк](#Методы%20разделения%20и%20соединения%20строк)**
	**[`split()`](#`split(sep=None,%20maxsplit=-1)%20->%20list`)**
	**[`join()`](#join(iterable)%20->%20str)**
	**[`replace()`](#`replace(old,%20new[,%20count])%20->%20str`)**
	**[`splitlines()`](#`splitlines([keepends%20bool])%20->%20list`)**
	**[`partition()`](#`partition(sep)`)**
	**[`rpartition()`](#`rpartition(sep)`)**
	**[`removeprefix()`](#`removeprefix(prefix)`)**
	**[`removesuffix()`](#`removesuffix(suffix)`)**
	
- **[Методы форматирования символьных строк](#Методы%20форматирования%20символьных%20строк)**
	**[`format()`](#`format(args,%20kwargs)`)**
	**[`format_map()`](#`format_map(mapping)`)**
	**[`encode()`](#`encode(encoding="utf-8",%20errors="strict")`)**
	**[`capitalize()`](#`capitalize()`)**
	**[`expandtabs()`](#`expandtabs(tab%20=%208)`)**
	**[`strip()`](#`strip([chars%20str])`)**
	**[`lstrip()`](#`lstrip([chars%20str])`)**
	**[`rstrip()`](#`rstrip([chars%20str])`)**
	**[`swapcase()`](#`swapcase()`)**
	**[`upper()`](#`upper()`)**
	**[`lower()`](#`lower()`)**
	**[`casefold()`](#`casefold()`)**
	**[`ljust()`](#`ljust(ширина%20[,%20заполнение])`)**
	**[`rjust()`](#`rjust(ширина%20[,%20заполнение])`)**
	**[`center()`](#`center(ширина%20[,%20заполнение])`)**
	**[`zfill()`](#`zfill(ширина)`)**
	**[`title()`](#`title()`)**
	
- **[Пользовательская транслитерация](#Пользовательская%20транслитерация)** 
	**`maketrans()`**
	**`translate()`**

- **[Проверка содержимого строк](#Проверка%20содержимого%20строк)**


### Методы поиска в строке
#поисквстроке

#### `find(sub[, start[, end]]) -> int`
Метод `str.find()` возвращает **индекс первого совпадения** подстроки `sub` в строке `str`, где подстрока или символ `sub` находится в пределах среза `str[start:end]`. Другими словами, находит и возвращает индекс первого совпадения подстроки в строке `str`.

-   Необязательные аргументы `start` и `end` интерпретируются как в [нотации среза](https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/izvlechenie-sreza-sequence-posledovatelnosti/ "Получение среза sequence[i:j] в Python.").
-   Индекс подстроки считается всегда от начала строки, а не от начала среза, если конечно он указан.
-   Метод возвращает `-1`, если символ или подстрока `sub` не найдены.


#### `rfind()`
Работает аналогично `find()`, но просматривает строку от конца к началу. 
> Строка при этом не инвертируется!

```python
a = 'aqbsd'

print(a.rfind('sb'))
#>>> -1
print(a.rfind('bs'))
#>>> 2
```


#### `index(sub[, start[, end]]) -> int`
Метод `str.index()` возвращает индекс **первого совпадения** начала подстроки `sub` в строке `str`, где подстрока или символ `sub` находится в пределах среза `str[start:end]`.

Работает аналогично методу строки `str.find()`, за исключением того, что бросает исключение `ValueError`, если символ или подстрока `sub` не найдены в строке `str`.

-   Необязательные аргументы `start` и `end` интерпретируются как в [нотации среза](https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/izvlechenie-sreza-sequence-posledovatelnosti/ "Получение среза sequence[i:j] в Python.").
-   Индекс подстроки считается всегда от начала строки, а не от начала среза, если конечно он указан.
-   Метод бросает исключение `ValueError`, если символ или подстрока `sub` не найдены.


#### `rindex()`
Работает аналогично `rfind()` за исключением того, что бросает исключение `ValueError`, если символ или подстрока `sub` не найдены в строке `str`


#### `count(sub[, start[, end]]) -> int`
Метод `str.count()` возвращает количество вхождений подстроки `sub` в строку `str` в диапазоне индексов `[start, end]`, если они переданы в метод.


#### `startswith(prefix[, start[, end]]) -> bool`
Метод `str.startswith()` возвращает `True`, если строка `str` **начинается указанным префиксом `prefix`**, в противном случае возвращает `False`.

Ограничивать поиск начала строки можно необязательными индексами `start` и `end`. В этом случае префикс будет искаться от начала среза.

>  Префикс `prefix` также может быть `кортежем` префиксов для поиска.


#### `endswith()`
Работает аналочично `startswith()`, но поиск осуществляется в конце
<br><br>
### Методы разделения и соединения строк

#### `split(sep=None, maxsplit=-1) -> list`
Метод `str.split()` возвращает список слов (подстрок) в строке, используя `sep` в качестве разделителя строки `str`. Если задан `maxsplit`, то выполняется не более `maxsplit` разбиений, таким образом, список будет иметь не более maxsplit+1 элементов. Если `maxsplit` не указан или равен `-1`, то делаются все возможные разделения строки `str`.

Если указан разделитель `sep`, то последовательные разделители в обрабатываемой строке не группируются вместе, а считаются разделителями пустых подстрок. Аргумент `sep` может состоять из нескольких символов. Разбиение _пустой_ строки `str` с указанным разделителем возвращает значение `["]`.
```python
print('1<>2<><>3'.split('<>'))
#>>> ['1', '2', '', '3'])
```
Если `sep` не указан или задан `None`, применяется другой алгоритм разбиения:

Последовательности пробелов рассматриваются как один разделитель и если строка имеет начальные или конечные пробелы, то результат не будет содержать пустых строк в начале или конце. Следовательно, разбиение _пустой_ строки или строки, состоящей только из пробела с разделителем `None`, возвращает пустой список `[]`
```python
print('1    2    3'.split(maxsplit=1))
#>> ['1', '2    3']
```


#### `join(iterable) -> str`
Метод `str.join()` возвращает строку, которая является конкатенацией (объединением) всех строк-элементов итерируемого объекта `iterable`.

В итоговой строке элементы объединяются между собой при помощи строки-разделителя `str`.

Если в последовательности `iterable` есть какие-либо НЕ строковые значения, включая байтовые строки `bytes`, то поднимается [исключение `TypeError`](https://docs-python.ru/tutorial/vstroennye-iskljuchenija-interpretator-python/vstroennye-iskljuchenija/ "Исключения наследуемые от Exception в Python.").
> `join()` работает быстрее чем конкатенация строк


#### `replace(old, new[, count]) -> str`
Метод `str.replace()` вернет копию строки, в которой все вхождения подстроки `old` заменены на подстроку `new`.

Если указан необязательный аргумент `count`, заменяются только первые вхождения `count`.


#### `splitlines([keepends: bool]) -> list`
Метод `str.splitlines()` возвращает список строк, текста `str`, разделенного по универсальным разрывам строк. Разрывы (разделители) строк не включаются в результирующий список, если не задано значение `keepends=True`.

Универсальные разрывы (разделители) строк представляют собой надмножество [escape-последовательностей](https://docs-python.ru/tutorial/strokovye-bajtovye-literaly/escape-posledovatelnosti-python/ "escape-последовательности в Python").

В методе строки `str.splitlines()` определены следующие разделители (разрывы) строк:

-   `\n` - Перевод строки
-   `\r` - Возврат каретки
-   `\r\n` - Возврат каретки + перевод строки
-   `\v` или `\x0b` - Табуляция строк
-   `\f` или `\x0c` - Подача страницы
-   `\x1c` - Разделитель файлов
-   `\x1d` - Разделитель групп
-   `\x1e` - Разделитель записей
-   `\x85` - Следующая строка (контрольный код C1)
-   `\u2028` - Разделитель строк
-   `\u2029n` - Разделитель абзацев


#### `partition(sep)`
-   `sep` - [`str`](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-str-tekstovye-stroki/ "Текстовые строки str в Python."), строка (символ) разделитель

###### Возвращаемое значение:
-   `tuple` кортеж, содержащий 3 строки

Метод `str.partition()` разбивает строку при **первом появлении** разделителя `sep` и вернет кортеж, содержащий часть строки `str` перед разделителем, сам разделитель `sep` и часть строки `str` после разделителя.

-   Разделитель `sep` может содержать как один, так и несколько символов.
-   Если разделитель не найден, вернуть кортеж, содержащий саму строку `str`, за которой следуют две пустые строки `(str, '', '')`.
-   При вызове метода без аргументов поднимается исключение `TypeError: partition() takes exactly one argument (0 given)`

В случаях, когда требуется, чтобы деление строки происходило при последнем появлении разделителя, используйте `str.rpartition()`.


#### `rpartition(sep)`
аналогично предыдущему


#### `removeprefix(prefix)`
Если исходная строка `str` начинается со строки префикса `prefix`, то метод `str.removeprefix()` возвращает копию строки без префикса `string[len(prefix):]`.

Если префикс `prefix` в исходной строке `str` не обнаружен, то метод возвращает копию исходной строки `str`.


#### `removesuffix(suffix)`
аналогично предыдущему
<br><br>
### Методы форматирования символьных строк

#### `format(*args, **kwargs)`
**[Описание вынесено в отдельный блок](str%20-%20форматирование.md)**


#### `format_map(mapping)`
-   `mapping` - подкласс словаря `dict`.
 
###### Возвращаемое значение:
-   [`str`](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-str-tekstovye-stroki/ "Текстовые строки str в Python."), копия форматированной строки


Метод `str.format_map()` работает аналогично `str.format(**mapping)`, за исключением того, что `mapping` используется напрямую и не копируется в словарь `dict`.

Это полезно, если, например `mapping`, подкласс `dict`.
```python
>>> class Default(dict):
...     def __missing__(self, key):
...         return key
...
>>> '{name} was born in country'.format_map(Default(name='Guido'))
# 'Guido was born in country'
```


#### `encode(encoding="utf-8", errors="strict")`
Метод `str.encode()` вернет закодированную версию строки `str` как объект байтов. Другими словами кодирует текстовую строку `str` в [строку байтов](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-bytes-bajtovye-stroki/ "Байтовые строки bytes в Python."), используя указанную кодировку `encoding`.

Аргумент `encoding` по умолчанию используется `'utf-8'`. Для получения списка всех схем кодирования смотрите [Стандартные кодировки](https://docs.python.org/3/library/codecs.html#standard-encodings "Стандартные кодировки Python").

Аргумент `errors` может быть задан для установки другой схемы обработки ошибок. Значение по умолчанию для ошибок является `'strict'`, это означает, что при ошибке кодирования будет подниматься исключение `UnicodeError`.Другие стандартные значения обработчика ошибок, это `'ignore'`, `'replace'`, `'xmlcharrefreplace'`, `'backslashreplace'` или любое другое значение, зарегистрированное с помощью [`codecs.register_error()`](https://docs-python.ru/standart-library/modul-codecs-python/registratsija-novogo-obrabotchika-oshibok/ "Регистрация нового обработчика ошибок.").

Стандартные схемы обработки ошибок:

-   `strict` - возбуждается `UnicodeError`, при попадании _ошибочных символов_*;
-   `ignore` - _ошибочных символов_* пропускаются;
-   `replace` - _ошибочных символов_* заменяются на `?`;
-   `xmlcharrefreplace` - _ошибочных символов_* заменяются на соответствующее им XML-представление;
-   `backslashreplace` - _ошибочных символов_* заменяются на последовательности, начинающиеся с обратной косой черты;
-   `namereplace` - _ошибочных символов_* заменяются на последовательности вида `\N{...}`;
-   `surrogateescape` - заменяет каждый байт на код суррогата, от `U+DC80` до `U+DCFF`;
-   `surrogatepass` - игнорирует коды суррогатов. Используется со следующими кодеками: utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le;


#### `capitalize()`
Делает прописной первую букву  оставляя все остальные строчными


#### `expandtabs(tab = 8)`
Заменяет символы табуляции пробелами


#### `strip([chars: str])`
Удаляет начальные и конечные пробелы в строке, либо символы `chars` . 
```python
print('feeaaedffasasddff'.strip('aedf'))
# sas
```


#### `lstrip([chars: str])`
...слева
#### `rstrip([chars: str])`
...справа


#### `swapcase()`
Преобразует строчные буквы в прописные и наоборот


#### `upper()`
Преобразует все строчные буквы в прописные


#### `lower()`
Преобразует все прописные буквы в строчные


#### `casefold()`
Аналог метода `str.lower()`. Более корректно приводит строку к единому регистру для возможности сравнения с учетом особенностей разных (`locale`) языков


#### `ljust(ширина [, заполнение])`
Форматирование текста по левому краю путем дополнения строки до нужной ширины пробелами или символами заполнения


#### `rjust(ширина [, заполнение])`
...то же по правому краю


#### `center(ширина [, заполнение])`
...то же по центру


#### `zfill(ширина)`
Дополняет строку слева нулями до необходимой ширины. Нули добавляются после символов `-` ,`+` при их наличии. Ширина строки учитывается с учетом знака


#### `title()`
В каждом слове устанавливает прописную букву
<br><br>
### Пользовательская транслитерация
#транслитерация

#### `maketrans(alph: str, newalph: str[, exclude: str] | dict) -> dict`:
Создает правила транслитерации. 
Возвращает словарь `dict` содержащий в качестве ключей коды символов `ord()` первого параметра, в качестве значений или коды символов `ord()` второго параметра или строки произвольной длины.

В качестве параметров могут быть переданы: 
- 2 строки `str` - длины строк должны совпадать, иначе ошибка. (так же не обязательная третья строка, содержащая удаляемые символы)
- словарь `dict`, содержащий пары ключ-значение в виде односимвольных строк для ключа и произвольной длины строки для значения


#### `translate(alph: str, newalph: str[, exclude: str] | dict) -> str`:
Осуществляет транслитерацию согласно переданному параметру. Если порядок транслитерации для каких-либо символов не определен, возвращаются символы в исходном варианте
```python
trans = ''.maketrans({'а': 'A' ,'ш': 'SH', 'ч': 'CH', 'я': 'YA', 'к': None})
a = 'ашчяклмн'.translate(trans)
print(trans, a)
#>>> {1072: 'A', 1096: 'SH', 1095: 'CH', 1103: 'YA', 1082: None} ASHCHYAлмн

trans2 = str.maketrans('abc', 'АБЦ', 'ad')
b = 'abcdef'.translate(trans2)
print(trans2, b)
#>>> {97: 1040, 98: 1041, 99: 1062} БЦef

a = 'abcdef'
print(a.translate('abc', 'АБЦ', 'ad'))
#>>> БЦef
```
<br><br>
### Проверка содержимого строк

#### `isalnum()`
#### `isalpha()`
#### `isascii()`
#### `isdecimal()`
#### `isdigit()`
#### `isidentifier()`
#### `islower()`
#### `isnumeric()`
#### `isprintable()`
#### `isspace()`
#### `istitle()`
#### `isupper()`
