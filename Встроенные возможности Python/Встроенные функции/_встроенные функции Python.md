# Встроенные функции `Python`
#встроенныефункции
***

>### [Список функций алфавиту](встроенные%20функции%20по%20алфавиту.md)
>### [Список функций по назначению](встроенные%20функции%20по%20назначению.md)

## Атрибуты функций

[\_\_annotations__](#__annotations__) - доступ к аннотациям
[\_\_closure__](#__closure__) - нелокальные `nonlocal` переменные функции
[\_\_defaults__](#__defaults__) - значения функции по умолчанию
[\_\_dict__](#__dict__) - дополнительные атрибуты и методы
[\_\_doc__](#__doc__) - строка документирования функции
[\_\_name__](#__name__) - имя функции

### `__annotations__`:
Доступ к использованным в функции аннотациям можно получить через атрибут `__annotations__`, в котором аннотации представлены в виде словаря, где ключами являются названия параметров, а значениями – их типы. При этом, возвращаемое функцией значение хранится в записи с ключом `return`.

Приведенный ниже код:

```python
def print_hello(num1: int, num2: int, num3: int) -> float:
    return (num1 + num2 + num3) / 3

print(print_hello.__annotations__)
```

выводит:

```no-highlight
{'num1': <class 'int'>, 'num2': <class 'int'>, 'num3': <class 'int'>, 'return': <class 'float'>}
```

### `__closure__`:
возвращает кортеж, содержащий нелокальные `nonlocal` переменные, используемые функцией. Такие переменные нужны в первую очередь для того, чтобы хранить какие-то данные, относящиеся к функции, между вызовами функции. Локальные переменные стираются при выходе из функции, глобальные — сохраняются, но видны всему свету, а нелокальные — идеальное сочетание закрытости и «сохраняемости».
```python
def outer_function(arg):
    num = 5
	name = 'Timur'     # не используется во вложенной функции
    numbers = [1, 2, 3]
    def inner_function():      # определяем вложенную функцию
        print(arg)
        print(num)
        print(numbers)
    return inner_function      # возвращаем вложенную функцию
        
inner = outer_function('python')

for var in inner.__closure__:
    print(var.cell_contents)   # кортеж содержит специальный тип

# выводит:

python       # args
5            # num
[1, 2, 3]    # numbers
```

### `__defaults__`:
Кортеж со значениями функции по умолчанию
### `__dict__`:
словарь, который используется для динамического наделения функций дополнительным функционалом. Устанавливать и получать значения из данного атрибута можно используя два синтаксиса:

-   в стиле словаря: `func.__dict__['attr'] = value`
-   через точечную нотацию: `func.attr = value`

Словарь атрибутов может быть использован для кэширования уже вычисленных значений функции:
```python
def fib(num): 
	if num < 2: 
		return num 
	if num not in fib.__dict__: 
		fib.num = fib(num - 1) + fib(num - 2) 
	return fib.num
```

### `__doc__`:
Строка документирования
### `__name__`:
Имя функции



## Все встроенные функции:
***


### `callable()`:
#проверка_значений #проверка_является_функцией #значения_переменных 

Функция `callable()` принимает в качестве аргумента некоторый объект и возвращает `True`, если переданный объект является вызываемым, или `False` в противном случае.

Приведенный ниже код:

```python
print(callable(int))
print(callable(list))
print(callable(100))
print(callable([1, 2, 3]))
```

выводит:

```no-highlight
True
True
False
False
```


### `enumerate(sequence, start=0)`:
#итераторы 

Возвращает итератор, содержащий кортежи пар значений (порядковый номер, элемент коллекции). Порядковый номер начинается со `start`

#### Параметры:
-   `sequence` - любая коллекция, итератор, или объект, поддерживающий метод итератора `__next__()`,
-   `start` - число `int`, начальное значение счётчика.

#### Возвращаемое значение:
-   `tuple` - кортеж, содержащий пары ('счётчик', 'элемент') для элементов указанной коллекция.


### `eval(expression)`:
#парсинг #выполнение_кода #эмулятор_интерпретатора

Возвращает  результат выполнения кода, переданного в строковом параметре.

Не все языковые конструкции являются выражениями (expression). Операторами, которые нельзя использовать в качестве выражений, являются, например, `while, for, if, def, import, class, raise` и т.д.

Выражения, передаваемые в качестве аргумента функции `eval()`:
- имеют доступ ко всем встроенным функциям Python.
- имеют доступ ко всем локальным и глобальным переменным.

```python
expression = '7 + 10'

result = eval(expression)

print(type(result))
print(result)
```

выводит:

```no-highlight
<class 'int'>
17
```


### `exec()`:
#парсинг #выполнение_кода #эмулятор_интерпретатора 

Функция `exec()`, в отличие от [eval()](#eval%20expression), принимает блок кода и выполняет его, возвращая значение `None`. Аргумент функции:

-   `code` — строка, представляющая собой корректный блок кода

Блок кода, передаваемый в качестве аргумента функции `exec()`:
- имеет доступ ко всем встроенным функциям Python.
- имеет доступ ко всем локальным и глобальным переменным

Приведенный ниже код:

```python
code = '''a = 10
b = 20
print(a + b)'''

exec(code)

# выводит:

30
```

```python
code1 = 'print(sorted([3, 5, 4, 1, 2]))'
code2 = 'print(sum([3, 5, 4, 1, 2]))'
code3 = 'print(len([3, 5, 4, 1, 2]))'

exec(code1)
exec(code2)
exec(code3)

# выводит:

[1, 2, 3, 4, 5]
15
5
```


### `filter(func, iterable)`:
#итераторы #фильтр

Встроенная функция `filter()` фильтрует элементы переданного итерируемого объекта в соответствии с некоторой функцией и возвращает объект итератора.

Аргументы функции:

-   `func` — функция, которая принимает элемент последовательности и возвращает `bool` значение. Так же можно указать `None` (см. описание)
-   `iterable` — итерируемый объект

Функция `filter()` фильтрует элементы переданного объекта `iterable` при помощи функции `func`. Если фильтрующая функция `func` вернёт `False`, то элемент последовательности `iterable` не попадёт в результирующий итератор.

Если вместо фильтрующей функции `func` передать значение `None`, то каждый элемент последовательности будет проверен на соответствие значению `True`. Если элемент в логическом контексте возвращает значение `False`, то он не будет добавлен в результирующий итератор.

Приведенный ниже код:

```python
data = [1, 0, 10, '', None, [], [1, 2, 3], ()]
filtered_data = filter(None, data)
print(*filtered_data)

# выводит:

1 10 [1, 2, 3]
```



### `hasattr(object, name)`:
#проверка_значений #значения_переменных 

Функция `hasattr()` используется для проверки существования метода или атрибута. Она принимает два аргумента:

-   `object` — объект, в котором нужно проверить существование атрибута
-   `name` — имя проверяемого атрибута

Функция возвращает `True`, если `object` имеет атрибут `name`, или `False` в противном случае. 

Приведенный ниже код:

```python
print(hasattr('stepik', 'isalpha'))
print(hasattr([1, 2, 3], 'sort'))
print(hasattr(13, 'to_str'))
```

выводит:

```no-highlight
True
True
False
```


### `hash()`:
#хэш

Функция `hash()` принимает в качестве аргумента некоторый объект и возвращает целое число, представляющее хеш-значение переданного объекта.

>Таблица хешируемости встроенных в Python типов данных:

|**Тип данных**|**Хешируемость**|
|----------|------------|
|`bool`|✔️|
|`int`|✔️|
|`float`|✔️|
|`complex`|✔️|
|`str`|✔️|
|`list`|❌|
|`tuple`|✔️*|
|`set`|❌|
|`frozenset`|✔️*|
|`dict`|❌|

\*Неизменяемые множества (тип `frozenset`) и кортежи (тип `tuple`) хешируемы только при условии, что их элементы являются хешируемыми.


### `iter(object, sentinel)`:
#итераторы 

Создание итератора на основании коллекции
Имеет 2 режима запуска: с одним и двумя параметрами:

1) Если НЕТ аргумента `sentinel`, то первый аргумент `object` должен быть объектом-коллекцией, которая поддерживает протокол итераций метод `__iter__()` или он должен поддерживать протокол последовательности метод `__getitem__()` с целыми аргументами, начиная с `0`. Если он не поддерживает любой из этих протоколов, бросается исключение `TypeError`.
```python
a = '1234'
iter_a = iter(a)

print('Первый элемент итератора: ', next(iter_a))   # 1
for i in iter_a:
    print(i)    # 2  (первый элемент уже был получен ранее)
                # 3
                # 4

```
2) Если передается аргумент `sentinel`, то ожидается, что первый аргумент `object`, поддерживает вызов `__call__()`. В этом случае, созданный итератор будет вызывать указанный объект с каждым обращением к своему `__next__()` и проверять полученное значение на равенство со значением, переданным в аргумент `sentinel`. Если полученное значение равно `sentinel`, то бросается исключение `StopIteration`, иначе возвращается полученное значение.
```python
with open('mydata.txt') as fp:
    # читаем, пока не попадется пустая строка
    for line in iter(fp.readline, sentinel=''): 
        # Делаем что-то с line.
```


### `map(func, *iterable)`:
#итераторы 

Встроенная функция `map()` преобразует элементы переданного итерируемого объекта в соответствии с некоторой функцией и возвращает объект итератора. 
Количество итерации соответствует самому короткому параметру `iterable`, переданному функции `map()`

Аргументы функции:

-   `func` — функция, которая вызывается для каждого элемента итерируемого объекта
-   `iterable` — итерируемые объекты (количество параметров `iterable` должно соответствовать количеству принимаемых параметров функции `func`)


### `next(iterator, default)`:
#итераторы 

Функция `next()` возвращает следующий элемент итератора, вызвав его метод `__next__()`.

Если итератор исчерпан:
-   бросается исключение `StopIteration`, если значение по умолчанию `default` не задано;
-   возвращается значение `default`, если оно задано


### `open()`:
#итератор #работасфайлами

#### Синтаксис:

fp = open(file, mode='r', buffering=-1, encoding=None,
          errors=None, newline=None, closefd=True, opener=None)

#### Параметры:
-   `file` - абсолютное или относительное значение пути к файлу или файловый дескриптор] открываемого файла.
-   `mode` - необязательно, строка, которая указывает режим, в котором открывается файл. По умолчанию `'r'`. Варианты: `r`, `w`, `rt`, `wt`, `rb`, `wb`
-   `buffering` - необязательно, целое число, используемое для установки политики буферизации.
-   `encoding` - необязательно, кодировка, используемая для декодирования или кодирования файла.
-   `errors` - необязательно, строка, которая указывает, как должны обрабатываться ошибки кодирования и декодирования. Не используется в -бинарном режиме
-   `newline` - необязательно, режим перевода строк. Варианты: `None`, `'\n'`, `'\r'` и `'\r\n'`. Следует использовать только для текстовых файлов.
-   `closefd` - необязательно, `bool`, флаг закрытия файлового дескриптора.
-   `opener` - необязательно, пользовательский объект, возвращающий открытый дескриптор файла.

#### Возвращаемое значение:
-   [файловый объект (поток)](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-file-object-fajly-potoki/ "Тип файлового объекта file object в Python.").

### `repr()`:
#проверка_значений #значения_переменных #вычисление_выражений

Функция `repr()` принимает в качестве аргумента некоторый объект и возвращает строку, содержащую формальное (понятное интерпретатору) представление переданного объекта.

Приведенный ниже код:

```python
from datetime import date

print(repr('stepik'))
print(repr([1, 2, 3, 4]))
print(repr(date(2022, 1, 16)))
```

выводит:

```no-highlight
'stepik'
[1, 2, 3, 4]
datetime.date(2022, 1, 16)
```


### `reversed()`:
#итераторы 
Возвращает итератор с инвертированной (обратной) последовательностью


### `zip(*iterables, strict=False)`:
возвращает итератор типа `<class 'zip'>`, содержащий кортежи, где i-й кортеж содержит i-й элемент из каждого итерируемого объекта.

**Примечание:** по умолчанию значение аргумента `strict=False`, то есть функция `zip()` останавливается, когда исчерпывается самый короткий итерируемый объект. Если установить значение `strict=True`, то функция `zip()` проверяет длины итерируемых объектов, вызывая ошибку `ValueError`, если они не совпадают. C одним итерируемым аргументом функция `zip()` возвращает итератор из кортежей с одним элементом, без аргументов функция возвращает пустой итератор.